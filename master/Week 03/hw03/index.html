<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="description" content ="CS61A: Structure and Interpretation of Computer Programs" />
    <meta name="keywords" content ="CS61A, Computer Science, CS, 61A, Programming, John DeNero, Berkeley, EECS" />
    <meta name="author" content ="John DeNero, Soumya Basu, Kevin Chen, Rohan Chitnis, Timothy Greeno, Jessica Gu, Brian Hou, Robert Huang, Andrew Huang, Joy Jeng, Austin Le, Youri Park, Harold Pimentel, Sumukh Sridhara, Steven Tang, Michelle Tian, Alana Tran, Dickson Tsai, Max Wolffe, Albert Wu, Marvin Zhang" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <link rel="stylesheet" type="text/css" href="../../assets/css/resource.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/css/hw.css"/>


    <title>CS 61A: Homework 3 | CS 61A Spring 2015</title>

  </head>
  <body style="font-family: Georgia,serif;">
    <h1 id="title-main">CS 61A: Homework 3</h1>

    <p><em>Due by 11:59pm on Thursday, 2/19</em></p>

<h2>Instructions</h2>

<p>Download <a href="hw03.zip">hw03.zip</a>.  Inside the archive, you
will find a file called <a
  href="hw03.py">hw03.py</a>, along with a copy of the <a
  href="ok">OK</a> autograder.</p>



<p><strong>Submission:</strong> When you are done, submit with
<code>python3 ok --submit</code>. You may submit more than once before
the deadline; only the final submission will be scored.</p>

<h2>Using OK</h2>

<p>The <code>ok</code> program helps you test your code and track your progress.
The first time you run the autograder, you will be asked to log in with your
@berkeley.edu account using your web browser. Please do so. Each time you run
ok, it will back up your work and progress on our servers.

You can run all the doctests with the following command:</p>

<pre><code>python3 ok</code></pre>

<p>To test a specific question, use the <code>-q</code> option with the
name of the function:</p>

<pre><code>python3 ok -q &lt;function&gt;</code></pre>

<p>By default, only tests that <strong>fail</strong> will appear. If you
want to see how you did on all tests, you can use the <code>-v</code>
option:</p>

<pre><code>python3 ok -v</code></pre>

<p>If you do not want to send your progress to our server or you have any
problems logging in, add the <code>--local</code> flag to block all
communication:</p>

<pre><code>python3 ok --local</code></pre>

<p>When you are ready to submit, run <code>ok</code> with the
<code>--submit</code> option:</p>

<pre><code>python3 ok --submit</code></pre>

<p><strong>Readings:</strong> You might find the following references
useful:</p>

<ul>
  <li><a href="http://composingprograms.com/pages/17-recursive-functions.html">Section 1.7</a></li>
</ul>

    <h2 id='table-of-contents'>Table of Contents</h2>
    <ul>
  <li><a href="index.html#q1">Question 1</a></li>
  <li><a href="index.html#q2">Question 2</a></li>
  <li><a href="index.html#q3">Question 3</a></li>
  <li><a href="index.html#q4">Question 4</a></li>
  <li><a href="index.html#q5">Question 5</a></li>
  <li><a href="index.html#q6">Question 6: Challenge Problem (optional)</a></li>
</ul>


    

<h3 class="question" id="q1">Question 1</h3>

<p>A mathematical function <code>G</code> on positive integers is defined by two
cases:</p>

<pre><code>G(n) = n,                                       if n &lt;= 3
G(n) = G(n &#x2d; 1) + 2 * G(n &#x2d; 2) + 3 * G(n &#x2d; 3),  if n &gt; 3</code></pre>

<p>Write a recursive function <code>g</code> that computes <code>G(n)</code>. Then, write an
iterative function <code>g_iter</code> that also computes <code>G(n)</code>:</p>

<pre><code>def g(n):
    &quot;&quot;&quot;Return the value of G(n), computed recursively.

    &gt;&gt;&gt; g(1)
    1
    &gt;&gt;&gt; g(2)
    2
    &gt;&gt;&gt; g(3)
    3
    &gt;&gt;&gt; g(4)
    10
    &gt;&gt;&gt; g(5)
    22
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"

def g_iter(n):
    &quot;&quot;&quot;Return the value of G(n), computed iteratively.

    &gt;&gt;&gt; g_iter(1)
    1
    &gt;&gt;&gt; g_iter(2)
    2
    &gt;&gt;&gt; g_iter(3)
    3
    &gt;&gt;&gt; g_iter(4)
    10
    &gt;&gt;&gt; g_iter(5)
    22
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q2">Question 2</h3>

<p>Write a function <code>has_seven</code> that takes a positive integer <code>n</code> and
returns whether <code>n</code> contains the digit 7.  <em>Do not use any assignment
statements - use recursion instead</em>:</p>

<pre><code>def has_seven(k):
    &quot;&quot;&quot;Returns True if at least one of the digits of k is a 7, False otherwise.

    &gt;&gt;&gt; has_seven(3)
    False
    &gt;&gt;&gt; has_seven(7)
    True
    &gt;&gt;&gt; has_seven(2734)
    True
    &gt;&gt;&gt; has_seven(2634)
    False
    &gt;&gt;&gt; has_seven(734)
    True
    &gt;&gt;&gt; has_seven(7777)
    True
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q3">Question 3</h3>

<p>The ping-pong sequence counts up starting from 1 and is always either counting
up or counting down.  At element k, the direction switches if k is a multiple
of 7 or contains the digit 7.  The first 30 elements of the ping-pong sequence
are listed below, with direction swaps marked using brackets at the 7th, 14th,
17th, 21st, 27th, and 28th elements:</p>

<pre><code>1 2 3 4 5 6 [7] 6 5 4 3 2 1 [0] 1 2 [3] 2 1 0 [&#x2d;1] 0 1 2 3 4 [5] [4] 5 6</code></pre>

<p>Implement a function <code>pingpong</code> that returns the nth element of the
ping-pong sequence. <em>Do not use any assignment statements; however, you
may use <code>def</code> statements</em>.</p>

<p><em>Hint</em>: If you're stuck, try implementing <code>pingpong</code> first using
assignment and a <code>while</code> statement, then try a recursive implementation
without assignment:</p>

<pre><code>def pingpong(n):
    &quot;&quot;&quot;Return the nth element of the ping&#x2d;pong sequence.

    &gt;&gt;&gt; pingpong(7)
    7
    &gt;&gt;&gt; pingpong(8)
    6
    &gt;&gt;&gt; pingpong(15)
    1
    &gt;&gt;&gt; pingpong(21)
    &#x2d;1
    &gt;&gt;&gt; pingpong(22)
    0
    &gt;&gt;&gt; pingpong(30)
    6
    &gt;&gt;&gt; pingpong(68)
    2
    &gt;&gt;&gt; pingpong(69)
    1
    &gt;&gt;&gt; pingpong(70)
    0
    &gt;&gt;&gt; pingpong(71)
    1
    &gt;&gt;&gt; pingpong(72)
    0
    &gt;&gt;&gt; pingpong(100)
    2
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q4">Question 4</h3>

<p>Once the machines take over, the denomination of every coin will be a
power of two: 1-cent, 2-cent, 4-cent, 8-cent, 16-cent, etc.  There will
be no limit to how much a coin can be worth.</p>

<p>A set of coins makes change for <code>n</code> if the sum of the values of the
coins is <code>n</code>.  For example, the following sets make change for <code>7</code>:</p>

<ul>
  <li>7 1-cent coins</li>
  <li>5 1-cent, 1 2-cent coins</li>
  <li>3 1-cent, 2 2-cent coins</li>
  <li>3 1-cent, 1 4-cent coins</li>
  <li>1 1-cent, 3 2-cent coins</li>
  <li>1 1-cent, 1 2-cent, 1 4-cent coins</li>
</ul>

<p>Thus, there are 6 ways to make change for <code>7</code>.  Write a function
<code>count_change</code> that takes a positive integer <code>n</code> and returns the number
of ways to make change for <code>n</code> using these coins of the future:</p>

<pre><code>def count_change(amount):
    &quot;&quot;&quot;Return the number of ways to make change for amount.

    &gt;&gt;&gt; count_change(7)
    6
    &gt;&gt;&gt; count_change(10)
    14
    &gt;&gt;&gt; count_change(20)
    60
    &gt;&gt;&gt; count_change(100)
    9828
    &quot;&quot;&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q5">Question 5</h3>

<p>A classic puzzle called the Towers of Hanoi is a game that consists of three
rods, and a number of disks of different sizes which can slide onto any rod.
The puzzle starts with <code>n</code> disks in a neat stack in ascending order of size on
a <code>start</code> rod, the smallest at the top, forming a conical shape.</p>

<p><img src="assets/tower.jpg" alt="Towers of Hanoi"></p>

<p>The objective of the puzzle is to move the entire stack to an <code>end</code> rod,
obeying the following rules:</p>

<ul>
  <li>Only one disk may be moved at a time.</li>
  <li>Each move consists of taking the top (smallest) disk from one of the rods and
  sliding it onto another rod, on top of the other disks that may already be
  present on that rod.</li>
  <li>No disk may be placed on top of a smaller disk.</li>
</ul>

<p>Complete the definition of <code>towers_of_hanoi</code> which prints out the steps
to solve this puzzle for any number of <code>n</code> disks starting from the
<code>start</code> rod and moving them to the <code>end</code> rod:</p>

<pre><code>def towers_of_hanoi(n, start, end):
    &quot;&quot;&quot;Print the moves required to solve the towers of hanoi game, starting
    with n disks on the start pole and finishing on the end pole.

    The game is to assumed to have 3 poles.

    &gt;&gt;&gt; towers_of_hanoi(1, 1, 3)
    Move the top disk from rod 1 to rod 3
    &gt;&gt;&gt; towers_of_hanoi(2, 1, 3)
    Move the top disk from rod 1 to rod 2
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 2 to rod 3
    &gt;&gt;&gt; towers_of_hanoi(3, 1, 3)
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 1 to rod 2
    Move the top disk from rod 3 to rod 2
    Move the top disk from rod 1 to rod 3
    Move the top disk from rod 2 to rod 1
    Move the top disk from rod 2 to rod 3
    Move the top disk from rod 1 to rod 3
    &quot;&quot;&quot;
    assert 0 &lt; start &lt;= 3 and 0 &lt; end &lt;= 3 and start != end, &quot;Bad start/end&quot;
    "*** YOUR CODE HERE ***"</code></pre>

<h3 class="question" id="q6">Question 6: Challenge Problem (optional)</h3>

<p>The recursive factorial function can be written as a single expression
by using a <a href="http://docs.python.org/py3k/reference/expressions.html#conditional-expressions">conditional expression</a>.</p>

<pre><code>&gt;&gt;&gt; fact = lambda n: 1 if n == 1 else mul(n, fact(sub(n, 1)))
&gt;&gt;&gt; fact(5)
120</code></pre>

<p>However, this implementation relies on the fact (no pun intended) that
<code>fact</code> has a name, to which we refer in the body of <code>fact</code>.  To write a
recursive function, we have always given it a name using a <code>def</code> or
assignment statement so that we can refer to the function within its
own body.  In this question, your job is to define fact recursively
without giving it a name!</p>

<p>Write an expression that computes <code>n</code> factorial using only call
expressions, conditional expressions, and lambda expressions (no
assignment or def statements).  <em>Note in particular that you are not
allowed to use <code>make_anonymous_factorial</code> in your return expression.</em>
The <code>sub</code> and <code>mul</code> functions from the <code>operator</code> module are the only
built-in function required to solve this problem:</p>

<pre><code>from operator import sub, mul

def make_anonymous_factorial():
    &quot;&quot;&quot;Return the value of an expression that computes factorial.

    &gt;&gt;&gt; make_anonymous_factorial()(5)
    120
    &quot;&quot;&quot;
    return &#x27;YOUR_EXPRESSION_HERE&#x27;</code></pre>

  </body>

  
</html>
